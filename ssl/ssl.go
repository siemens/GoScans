/*
* GoScans, a collection of network scan modules for infrastructure discovery and information gathering.
*
* Copyright (c) Siemens AG, 2016-2021.
*
* This work is licensed under the terms of the MIT license. For a copy, see the LICENSE file in the top-level
* directory or visit <https://opensource.org/licenses/MIT>.
*
 */

package ssl

import (
	"context"
	"fmt"
	"github.com/noneymous/GoSslyze"
	"github.com/siemens/GoScans/utils"
	"math/big"
	"strconv"
	"strings"
	"time"
)

const Label = "Ssl"

var (
	sslyzeVersion = []int{5, 0, -1}
)

/*
 * This is a short summary of things that need to be revisited, can be improved or added.
 *
 * - First and foremost we should add check for some of the possible errors returned by SSLyze (e.g. Timeout, ...) and
 * 		handle them accordingly (See discovery scan module).
 *
 * - We can not parse every certificate. Go crashes if for example the public key algorithm is ECDSA
 *		and the curve is not implemented in Go. This is why we try to get most of the info from SSLyze.
 *		Another issue with Go's certificate parser is that it can only detect RSA, DSA and ECDSA public keys. So it can
 * 		NOT detect any of the GOST or any deprecated algorithms.
 *	-> It would be nice if we can:
 *		- get even more information from SSLyze 											(probably need to implement them ourselves and create a PR)
 * 		- find another parser that doesn't rely on Go's implementation 						(have not found one yet)
 *			This could also be a parser written in C, Python, etc.
 *		- implement our own parser, starting with a fork of the x509 package				(probably only solution, but very time consuming)
 *
 * - We are currently not able to retrieve any information on the key size or the strength of the key. SSLyze had some
 *		information when the key exchange was a DH key exchange, but removed it and it seems like it won't come back
 *		anytime soon.
 *	-> The only place to get mor information about these keys is the 'clientHello' (and 'serverHello') messages of the
 * 		TLS protocol. Therefore both solutions for this problem are quiet similar:
 * 		- add the information to the output of SSLyze										(might not be feasible as SSLyze relies on OpenSSL and OpenSSL probably does not expose this kind of information)
 * 		- implement the TLS protocol up to the clientHello and the serverHello messages.	(at this point we could probably re-implement SSLyze in Golang (^.^') )
 *
 * - Another point would be the 'cipherInfos' slice, it could be improved by adding even more values - the ones that are
 *		automatically generated by 'parseCipherMapping'. In other words we could hard code the 'cipherMapping' and get
 *		rid of the parsing.
 *
 * - Because SSLyze relies on OpenSSL there's also the problem that SSLyze can only detect cipher suites supported by
 * 		OpenSSL. This point is not as bad as it sounds, because OpenSSL supports most of the cipher suites and SSLyze
 * 		includes two different versions of OpenSSL in order to support deprecated cipher suites as well. As most of those
 *		cipher suites are really old or rely on closed source algorithms their distribution should be fairly limited.
 *		Therefore the question rises whether this is a problem after all.
 */

// Setup configures the environment accordingly, if the scan module has some special requirements. A successful setup
// is required before a scan can be started.
func Setup(logger utils.Logger) error {
	return nil
}

// CheckSetup checks whether Setup() executed accordingly. Scan arguments should be checked by the scanner.
func CheckSetup() error {
	return nil
}

// StartTlsPorts maps common port numbers to their respective protocols: smtp, xmpp, xmpp_server, pop3, ftp, imap,
// ldap, rdp, postgres, auto.
// More (unofficial) ports from this list: https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers
var StartTlsPorts = map[int]string{
	433:  "",            // SMTP
	25:   "smtp",        // SMTP
	465:  "",            // SMTP
	587:  "smtp",        // SMTP
	143:  "imap",        // IMAP
	220:  "imap",        // IMAP - IMAPv3
	993:  "",            // IMAP
	109:  "pop3",        // POP3 - Actually POP2, but recognized by SSLyze.
	110:  "pop3",        // POP3
	995:  "",            // POP3
	5222: "xmpp",        // XMPP
	5223: "",            // XMPP
	5280: "xmpp",        // XMPP - This wouldn't be recognized by SSLyze.
	5298: "xmpp",        // XMPP - This wouldn't be recognized by SSLyze.
	5269: "xmpp_server", // XMPP-Server
	21:   "ftp",         // FTP
	990:  "",            // FTP - Connection init
	989:  "",            // FTP - Data transfer
	389:  "ldap",        // LDAP
	3268: "ldap",        // LDAP - Microsoft Global Catalog
	7389: "ldap",        // LDAP - This wouldn't be recognized by SSLyze.
	636:  "",            // LDAP
	3269: "",            // LDAP - Microsoft Global Catalog over SSL
	7636: "",            // LDAP
	3389: "rdp",         // RDP
	5432: "postgres",    // Postgres
}

type Issues struct {
	// ATTENTION: When changing any of the following structs, change the compareResultData function accordingly!
	AnyChainInvalid              bool     // Indicates whether any certificate chain is invalid.
	AnyChainInvalidOrder         bool     // Indicates whether any certificate chain has an invalid order.
	LowestProtocol               Protocol // The lowest SSL / TLS version that is supported by the server.
	MinStrength                  int      // The minimum of EncryptionStrength, MacStrength(/PrfStrength) and PublicKeyStrength across all ciphers and certificates.
	InsecureRenegotiation        bool     // Indicates whether the server supports secure renegotiation.
	AcceptsClientRenegotiation   bool     // If set renegotiation can be initialized by the client.
	InsecureClientRenegotiation  bool     // Combination of InsecureRenegotiation and AcceptsClientRenegotiation.
	SessionResumptionWithId      bool     // If set a session resumption using IDs is possible.
	SessionResumptionWithTickets bool     // If set a session resumption using session tickets is possible.
	NoPerfectForwardSecrecy      bool     // If this is set, the server supports at least one cipher suite that does not provide prefect forward secrecy.
	Compression                  bool     // If set compression for the payload is available (leading to CRIME vulnerability).
	ExportSuite                  bool     // Indicates whether the server supports an export cipher suite.
	DraftSuite                   bool     // Indicates whether the server supports a draft cipher suite.
	Sslv2Enabled                 bool     // Indicates the presence of at least one SSLv2 cipher suite.
	Sslv3Enabled                 bool     // Indicates the presence of at least one SSLv3 cipher suite.
	Rc4Enabled                   bool     // Indicates the presence of at least one cipher suite with RC4 encryption.
	Md2Enabled                   bool     // Indicates the presence of at least one cipher suite with MD2 mac (/prf).
	Md5Enabled                   bool     // Indicates the presence of at least one cipher suite with MD5 mac (/prf).
	Sha1Enabled                  bool     // Indicates the presence of at least one cipher suite with SHA1 mac (/prf).
	EarlyDataSupported           bool     // Early data can have a negative impact if session management is not implemented carefully.
	CcsInjection                 bool     // 									(https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-0224)
	Beast                        bool     // 									(https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2011-3389)
	Heartbleed                   bool     // http://heartbleed.com/				(https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-0160)
	Lucky13                      bool     // 									(https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2013-0169)
	Poodle                       bool     // 									(https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-3566) (https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-8730)
	Freak                        bool     // https://freakattack.com			(https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2015-0204)
	Logjam                       bool     // https://weakdh.org/logjam.html		(https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2015-4000) (Currently only export ciphers are tested)
	Sweet32                      bool     // https://sweet32.info/ 				(https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2016-2183)
	Drown                        bool     // https://drownattack.com/ 			(https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2016-0800)
	IsCompliantToMozillaConfig   bool     // https://ssl-config.mozilla.org/    Check if the server's SSL config complies with the recommended one from Mozilla
}

type Cipher struct {
	Id                  string
	IanaName            string
	OpensslName         string
	Protocol            Protocol       // SSL/TLS version used.
	KeyExchange         KeyExchange    // The key exchange algorithm.
	KeyExchangeBits     int            // The encryption's key bit-size - only set if ephemeral key exchange or export cipher.
	KeyExchangeStrength int            // The encryption's strength corresponding to the key size - only set if ephemeral key exchange or export cipher.
	KeyExchangeInfo     []string       // Additional info on the key exchange - only set if ephemeral key exchange
	ForwardSecrecy      bool           // Set if the key exchange algorithm supports forward secrecy.
	Authentication      Authentication // The authentication algorithm.
	Encryption          Encryption     // The encryption algorithm.
	EncryptionMode      EncryptionMode // The encryption's mode.
	EncryptionBits      int            // The encryption's key bit-size.
	EncryptionStrength  int            // The encryption's strength corresponding to the key size.
	BlockCipher         bool           // Indicates whether the encryption method is a block cipher.
	BlockSize           int            // The encryption's block size if it is a block cipher.
	StreamCipher        bool           // Indicates whether the encryption method is a stream cipher.
	Mac                 Mac            // The message authentication code algorithm.
	MacBits             int            // The mac's digest size in bits.
	MacStrength         int            // The mac's strength corresponding to the digest size.
	Prf                 Prf            // The pseudo-random function family algorithm (if any).
	PrfBits             int            // The prf's digest size in bits.
	PrfStrength         int            // The prf's strength corresponding to the digest size.
	Export              bool           // Indicates whether the cipher suite is an old export cipher suite.
	Draft               bool           // Indicates whether the cipher suite is a draft.
}

type CertDeployment struct {
	Certificates  []*Certificate // Certificates of this specific deployment
	ValidatedBy   []string       // Name(s) of the trust store(s) that successfully validated this deployment
	HasValidOrder bool           // Indicates whether the certificate chain was sent in valid order
}

type Certificate struct {
	Type                   string             // 'leaf' / 'intermediate' / 'root'
	Version                int                // Version of the X.509 standard.
	Serial                 big.Int            // Serial number chosen by the CA (not necessarily globally unique / random).
	Subject                []string           // Object Identifiers (OIDs) of the subject.
	SubjectCN              string             // Subject's common name.
	Issuer                 []string           // Object Identifiers (OIDs) of the issuer.
	IssuerCN               string             // Issuer's common name.
	AlternativeNames       []string           // Subject's alternative names.
	ValidFrom              time.Time          // The initial date at which the certificate is valid.
	ValidTo                time.Time          // The expiration date of the certificate.
	PublicKeyAlgorithm     PublicKey          // The algorithm corresponding to the public key.
	PublicKeyInfo          string             // Some additional info on the public key, depending on the public key's type.
	PublicKeyBits          uint64             // The public key's bit-size.
	PublicKeyStrength      int                // The public key's strength corresponding to the key size.
	SignatureAlgorithm     SignatureAlgorithm // The signature algorithm.
	SignatureHashAlgorithm SignatureHash      // The signature hash algorithm.
	CrlUrls                []string           // URL(s) for the certificate revocation list.
	OcspUrls               []string           // URL(s) for the  online certificate status protocol
	KeyUsage               []string           // Key usage flags set in the certificate.
	ExtendedKeyUsage       []string           // Extended key usage flags set in the certificate.
	BasicConstraintsValid  bool               // Indicates whether Ca and MaxPathLen is valid. All three fields belong to the "basic constraint extension"
	Ca                     bool               // Indicates whether the certificate is of a CA.
	MaxPathLength          int                // Maximum number of non-self-issued intermediate certificates that follow this certificate (leaf certificate not counting). See also: http://www.pkiglobe.org/
	Sha1Fingerprint        string             // SHA1 fingerprint of the certificate.
}

type Data struct {
	Vhost                 string             // The target's hostname
	Issues                *Issues            // Cipher basic info
	Ciphers               map[string]*Cipher // Map of [protocol + "|" + cipher id] = cipher
	CertDeployments       []*CertDeployment  // A server can have multiple certificate chains, e.g. in order to support older clients. Unfortunately SSLyze does not return any information on which chain is linked to which client (/Cipher/Server name used for SNI...)
	EllipticCurves        *EllipticCurves    // Information about the elliptic curves that the target supports or rejects
	ComplianceTestDetails string             // Details to the check against Mozilla's SSL config. Each target will have its own IsCompliant flag, but this variable contains further details of the check.
}

type EllipticCurves struct {
	RejectedCurves         []EllipticCurve // The curves that the target rejects
	SupportedCurves        []EllipticCurve // The curves that the target accepts
	SupportECDHKeyExchange bool            // Indicates whether the target supports ECDH Key Exchange
}

type EllipticCurve struct {
	Name       string
	OpenSSLnid int
}

type Result struct {
	Data      []*Data
	Status    string // Final scan status (success or graceful error). Should be stored along with the scan results.
	Exception bool   // Indicates if something went wrong badly and results shall be discarded. This should never be
	// true, because all errors should be handled gracefully. Logging an error message should always precede setting
	// this flag! This flag may additionally come along with a message put into the status attribute.
}

type Scanner struct {
	Label          string
	Started        time.Time
	Finished       time.Time
	logger         utils.Logger                 // Can be any logger implementing our minimalistic interface. Wrap your logger to satisfy the interface, if necessary (like utils.LoggerTest).
	target         string                       // Target address to be scanned (might be IPv4, IPv6 or hostname)
	port           int                          //
	vhosts         []string                     // Alternative server names
	deadline       time.Time                    // Time when the scanner has to abort
	sslyzeScanners map[string]*gosslyze.Scanner // Sslyze scanner objects to be executed
}

func newScanner( // Private, because the public factories are in the os specific files
	logger utils.Logger, // Can be any logger implementing our minimalistic interface. Wrap your logger to satisfy the interface, if necessary (like utils.LoggerTest).
	sslyzeCommand string, // Executable to call or Python3 SSLyze call, depending on operating system
	sslyzeCommandArgs []string,
	sslyzeAdditionalTruststore string, // Sslyze always applies default CAs, but you can add additional ones via custom trust store
	target string,
	port int,
	vhosts []string,
) (*Scanner, error) {

	// Check whether input target is valid
	if !utils.IsValidAddress(target) {
		return nil, fmt.Errorf("invalid target '%s'", target)
	}

	// Use generated OS trust store, if no custom one is provided
	if len(sslyzeAdditionalTruststore) != 0 {
		errStore := utils.IsValidFile(sslyzeAdditionalTruststore)
		if errStore != nil {
			return nil, fmt.Errorf("invalid trust store file '%s'", sslyzeAdditionalTruststore)
		}
	}

	// Sanitize list of input vhosts
	vhosts = utils.Filter(vhosts, func(vhost string) bool { return utils.IsValidHostname(vhost) })

	// Remove duplicates
	vhosts = utils.RemoveFromSlice(vhosts, target)
	vhosts = utils.UniqueStrings(vhosts)

	// Initiate scanner with sanitized input values
	scan := Scanner{
		Label,
		time.Time{}, // zero time
		time.Time{}, // zero time
		logger,
		strings.TrimSpace(target),
		port,
		vhosts,
		time.Time{}, // zero time (no deadline yet set)
		make(map[string]*gosslyze.Scanner),
	}

	// Prepare SSLyze main scan with original target as SNI
	sslyzeScanner, errSslyze := initSslyze(sslyzeCommand, sslyzeCommandArgs, sslyzeAdditionalTruststore, target, port, target)
	if errSslyze != nil {
		return nil, errSslyze
	}
	scan.sslyzeScanners[target] = sslyzeScanner

	// Prepare SSLyze scans for vhosts as SNIs
	for _, vhost := range vhosts {

		// Prepare the SSLyze scan. Other scans target with sni=other hostname
		sslyzeScannerVhost, errSslyzeOther := initSslyze(sslyzeCommand, sslyzeCommandArgs, sslyzeAdditionalTruststore, target, port, vhost)
		if errSslyzeOther != nil {
			return nil, errSslyzeOther
		}
		scan.sslyzeScanners[vhost] = sslyzeScannerVhost
	}

	// Return scan struct
	return &scan, nil
}

// Run starts scan execution. This must either be executed as a goroutine, or another thread must be active listening
// on the scan's result channel, in order to avoid a deadlock situation.
func (s *Scanner) Run(timeout time.Duration) (res *Result) {

	// Recover potential panics to gracefully shut down scan
	defer func() {
		if r := recover(); r != nil {

			// Log exception with stacktrace
			s.logger.Errorf(fmt.Sprintf("Unexpected error: %s", r))

			// Build error status from error message and formatted stacktrace
			errMsg := fmt.Sprintf("%s%s", r, utils.StacktraceIndented("\t"))

			// Return result set indicating exception
			res = &Result{
				nil,
				errMsg,
				true,
			}
		}
	}()

	// Set scan started flag and calculate deadline
	s.Started = time.Now()
	s.deadline = time.Now().Add(timeout)
	s.logger.Infof("Started  scan of %s:%d.", s.target, s.port)

	// Execute scan logic
	res = s.execute()

	// Log scan completion message
	s.Finished = time.Now()
	duration := s.Finished.Sub(s.Started).Minutes()
	s.logger.Infof("Finished scan of %s:%d in %fm.", s.target, s.port, duration)

	// Return result set
	return res
}

func (s *Scanner) execute() *Result {

	// Declare variables
	result := Result{
		make([]*Data, 0, len(s.sslyzeScanners)),
		utils.StatusCompleted,
		false,
	}

	// Scan the different targets (target + vhosts) sequential. This way we can ease the stress on the server.
	for target, sslyzeScanner := range s.sslyzeScanners {

		// Calculate the remaining time for the whole SSL scan. This timeout will not stop the parsing of an SSLyze
		// result, but will stop a running SSLyze instance.
		if utils.DeadlineReached(s.deadline) {
			s.logger.Debugf("Scan ran into timeout.")

			// Get the list of outstanding targets
			remainingTargets := make([]string, 0, len(s.sslyzeScanners)-len(result.Data))
			for _, d := range result.Data {
				if _, okHostname := s.sslyzeScanners[d.Vhost]; !okHostname {
					remainingTargets = append(remainingTargets, d.Vhost)
				}
			}

			// Log outstanding work
			left := utils.Map(remainingTargets, func(e string) string { return "'" + e + "'" })
			s.logger.Debugf("Aborted vhost '%s', skipping vhosts '%s'.", target, strings.Join(left, ", "))

			// Adjust the status
			result.Status = utils.StatusDeadline
			break
		}

		// Create timeout context
		ctx, cancel := context.WithDeadline(context.Background(), s.deadline)

		// Apply timeout context to scanner.
		// In this case we actually could issue the timeout context during scanner initialization, because we don't call
		// the cancel func using a defer statement. But it could be broken by coming changes to the code structure and
		// we'd have to save the CancelFunc for every nmap scanner.
		sslyzeScanner.WithContext(ctx)

		// Execute SSLyze scan
		scanResult, errSslyze := sslyzeScanner.Run()

		// Check for errors
		if errSslyze != nil {

			// Release the resources associated with the context, if the timeout was not reached yet.
			cancel()

			// Check if the scan timed out
			if errSslyze.Error() == "SSLyze scan timed out" {
				s.logger.Debugf("SSLyze scan timout reached during SNI '%s'", target, errSslyze)
				result.Status = utils.StatusDeadline
				break
			}

			// We expect some scans of vhosts to fail therefore the overall scan is not failed, we only want to log it
			s.logger.Errorf("SSLyze scan failed for target '%s': %s", target, errSslyze)
			continue
		}

		// Release the resources associated with the context, if the timeout was not reached yet.
		cancel()

		// Parse the (raw) SSLyze scan result into our structs.
		parsedData := parseSslyzeResult(s.logger, target, scanResult)

		// Check if the scan returned something at all and drop empty results
		if len(parsedData.Ciphers) == 0 || len(parsedData.CertDeployments) == 0 {
			s.logger.Debugf("No SSL data discovered.")
			continue
		}

		// Check if we already found the same result for a different vhost.
		if isDuplicate(result.Data, parsedData) {
			s.logger.Debugf("Skipping duplicate result.") // Different vhost same result
			continue
		}

		// Append result
		result.Data = append(result.Data, parsedData)
	}

	// Return pointer to result struct
	s.logger.Debugf("Returning scan result")
	return &result
}

// initSslyze prepares the SSLyze scanner with the needed parameters.
func initSslyze(
	sslyzeCommand string,
	sslyzeCommandArgs []string,
	sslyzeAdditionalTruststore string,
	target string,
	port int,
	sni string,
) (*gosslyze.Scanner, error) {

	// Create new scanner
	s := gosslyze.NewScanner(sslyzeCommand, sslyzeCommandArgs...)

	// Set the target
	s.WithTarget(target, port)

	// Set scanner flags
	s.WithSslV3()
	s.WithSslV2()
	s.WithTlsV1()
	s.WithTlsV1_1()
	s.WithTlsV1_2()
	s.WithTlsV1_3()
	s.WithCcs()
	s.WithHeartbleed()
	s.WithRenegotiation()
	s.WithResume()
	s.WithResumeAttempts(10)
	s.WithCompression()
	s.WithFallback()
	s.WithRobot()
	s.WithCertInfo() // Validate certificate
	s.WithSni(sni)   // Specify the hostname to connect to using sni.
	s.WithEarlyData()
	s.WithEllipticCurves()
	s.WithMozillaConfig("intermediate") // Check server's config against Mozilla's intermediate recommended SSL config

	// Send a STARTTLS message to protocols like smtp, xmpp, pop3, ftp, ... The protocol will be determined based on
	// the port.
	if protocol, ok := StartTlsPorts[port]; ok && protocol != "" {
		s.WithStartTls(protocol)
	}

	// Sets the CA trust store, if a custom one is supplied. Otherwise the default ones will be taken.
	if len(sslyzeAdditionalTruststore) > 0 {
		s.WithCaFile(sslyzeAdditionalTruststore)
	}

	return &s, nil
}

// compareVersion compares the given version string retrieved from the python interpreter at pythonPath with the provided
// integer slice. Example wanted: []int{3, 5, -1}, where 3 is the major and 5 the minor version. A negative number
// signalizes to ignore this category.
// This little helper function is used when checking for Python and SSLyze before creating a new scanner.
func compareVersion(got string, wanted []int) (bool, error) {

	// Some sanity checks
	if len(wanted) != 3 {
		return false, fmt.Errorf("wanted version number should be of length 3 not %d", len(wanted))
	}

	gotCategories := strings.Split(got, ".")

	if len(gotCategories) != 3 {
		return false, fmt.Errorf("version number should be of length 3 not %d", len(gotCategories))
	}

	// Compare the major, minor and patch version
	for i, v := range gotCategories {
		if wanted[i] < 0 {
			continue
		}

		num, errAtoi := strconv.Atoi(v)
		if errAtoi != nil {
			return false, errAtoi
		}

		if num < wanted[i] {
			return false, nil
		}
	}

	return true, nil
}

// checkSSLyzeVersion extracts the installed SSLyze version from the help message and compares it to the required version
func checkSSLyzeVersion(msgHelp string) (bool, error) {
	versionIndex := strings.Index(msgHelp, "SSLyze version ")
	argumentsIndex := strings.Index(msgHelp, "positional arguments")

	// Abort if '--help' command did not return expected result
	if versionIndex == -1 || argumentsIndex == -1 {
		return false, fmt.Errorf(
			"could not extract SSLyze version, please update to '%s'",
			versionSliceToString(sslyzeVersion),
		)
	}

	// Extract and trim SSLyze's version number from help message
	version := strings.Trim(msgHelp[versionIndex+len("SSLyze version "):argumentsIndex], "\n\t\r ")

	// Check if used version is compatible to the required one
	versionOk, errVersion := compareVersion(version, sslyzeVersion)
	if errVersion != nil {
		return false, fmt.Errorf("could not validate SSLyze version '%s': %s", version, errVersion)
	}

	// Return version check
	return versionOk, nil
}

// This little helper function is used for error logging if the checks for Python and SSLyze before creating a new
// scanner fail.
func versionSliceToString(in []int) string {
	substrings := make([]string, len(in))
	for i, v := range in {
		if in[i] < 0 {
			substrings[i] = "x"
			continue
		}

		substrings[i] = strconv.Itoa(v)
	}

	return strings.Join(substrings, ".")
}
